<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–í–∞–ª–µ–Ω—Ç–∏–Ω–∫–∞ üíú</title>

  <style>
    :root{
      --bg1:#06060a; --bg2:#0b0820;
      --text:#f6f3ff; --muted:rgba(246,243,255,.75);
      --stroke:rgba(255,255,255,.14);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 700px at 20% 10%, #2a0f3a 0%, transparent 55%),
        radial-gradient(900px 600px at 90% 30%, #121b5c 0%, transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }
    .wrap{
      min-height:100%;
      display:grid; place-items:center;
      padding:22px; gap:10px; text-align:center;
    }
    .badge{
      padding:6px 12px;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.04);
      border-radius:999px;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--muted);
    }
    h1{margin:6px 0 0; font-size:clamp(26px,3.6vw,44px)}
    .sub{margin:0 0 12px; color:var(--muted)}

    .card{
      width:min(860px, 94vw);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius:24px;
      padding:16px;
      display:grid; gap:12px;
      box-shadow:0 18px 70px rgba(0,0,0,.55);
    }
    .stage{
      width:100%;
      height:min(560px, 66vh);
      border-radius:18px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      position:relative;
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    .btn{
      justify-self:center;
      cursor:pointer;
      border:none;
      padding:12px 16px;
      border-radius:14px;
      color:var(--text);
      background:linear-gradient(90deg, rgba(186,120,255,.86), rgba(126,105,255,.86));
      box-shadow: 0 12px 40px rgba(180,120,255,.18);
      font-weight:700;
    }
    .msg{
      text-align:left;
      padding:16px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
    }
    .hidden{display:none}
    .sig{margin-top:10px; opacity:.75; font-style:italic}
  </style>
</head>

<body>
  <main class="wrap">
    <div class="badge">üíå –í–ê–õ–ï–ù–¢–ò–ù–ö–ê</div>
    <h1>–ó—ñ —Å–≤—è—Ç–æ–º —É—Å—ñ—Ö –∑–∞–∫–æ—Ö–∞–Ω–∏—Ö üíú</h1>
    <p class="sub">–Ø —Ç–µ–±–µ –ª—é–±–ª—é, —Å–æ–Ω—Ü–µ </p>

    <section class="card">
      <div class="stage">
        <canvas id="c"></canvas>
      </div>

      <button id="btn" class="btn">–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ—Å–ª–∞–Ω–Ω—è</button>

      <div id="msg" class="msg hidden">
        <h2>–ú–æ—î –ø–æ—Å–ª–∞–Ω–Ω—è –¥–ª—è —Ç–µ–±–µ</h2>
        <p>
          –¢–∏ ‚Äî –º—ñ–π –ø—Ä–æ–º—ñ–Ω—á–∏–∫ —Å–æ–Ω—Ü—è, —â–æ —Ä–æ–±–∏—Ç—å –º–æ—ó –¥–Ω—ñ —Ç–µ–ø–ª—ñ—à–∏–º–∏. –î—è–∫—É—é, —â–æ —Ç–∏ —î. üíú<br/>
        </p>
        <div class="sig">‚Äî –¢–≤–æ—î —Å–æ–Ω–µ—á–∫–æ</div>
      </div>
    </section>
  </main>

  <script>
    // toggle
    const btn = document.getElementById("btn");
    const msg = document.getElementById("msg");
    btn.addEventListener("click", () => {
      msg.classList.toggle("hidden");
      btn.textContent = msg.classList.contains("hidden") ? "–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ—Å–ª–∞–Ω–Ω—è" : "–°—Ö–æ–≤–∞—Ç–∏ –ø–æ—Å–ª–∞–Ω–Ω—è";
    });

    // ===== FAST HEART: render once -> animate with drawImage =====
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:true });

    // Offscreen (pre-rendered heart)
    const off = document.createElement("canvas");
    const offCtx = off.getContext("2d", { alpha:true });

    const state = { w:0,h:0,cx:0,cy:0, dpr:1, burst:0, ready:false };

    // colors
    const CORE = "rgba(186,120,255,0.95)";
    const EDGE = "rgba(186,120,255,0.70)";
    const HALO = "rgba(186,120,255,0.30)";
    const GLOW = "rgba(120,70,255,0.70)";

    const rand = (a=0,b=1)=> a + Math.random()*(b-a);
    const randi = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));

    function heartXY(t){
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
      return {x,y};
    }
    function scatterInside(x, y, cx, cy, beta=0.15){
      const ratioX = -beta * Math.log(Math.random());
      const ratioY = -beta * Math.log(Math.random());
      const dx = ratioX * (x - cx);
      const dy = ratioY * (y - cy);
      return { x: x - dx, y: y - dy };
    }

    function resize(){
      const r = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      state.w = r.width; state.h = r.height;
      state.cx = r.width/2; state.cy = r.height/2;
      state.dpr = dpr;

      // offscreen at same logical size
      off.width  = Math.floor(r.width * dpr);
      off.height = Math.floor(r.height * dpr);
      offCtx.setTransform(dpr,0,0,dpr,0,0);

      prerenderHeart(); // rebuild once
    }
    window.addEventListener("resize", resize);

    function prerenderHeart(){
      const w = state.w, h = state.h, cx = state.cx, cy = state.cy;

      // clear
      offCtx.clearRect(0,0,w,h);

      // choose scale relative to stage
      const ENLARGE = Math.min(w,h) * 0.030;

      // counts (light)
      const baseN = 900;
      const edgeN = 1600;
      const centerN = 1200;
      const haloN = 1100;

      // build base outline points
      const base = [];
      for(let i=0;i<baseN;i++){
        const t = rand(0, Math.PI*2);
        const p = heartXY(t);
        base.push({ x: p.x*ENLARGE + cx, y: p.y*ENLARGE + cy });
      }

      // glow pass once
      offCtx.save();
      offCtx.globalCompositeOperation = "lighter";
      offCtx.shadowColor = GLOW;
      offCtx.shadowBlur = 18;

      // halo
      offCtx.fillStyle = HALO;
      for(let i=0;i<haloN;i++){
        const t = rand(0, Math.PI*2);
        const p = heartXY(t);
        const x = p.x*(ENLARGE*1.07) + cx + randi(-10,10);
        const y = p.y*(ENLARGE*1.07) + cy + randi(-10,10);
        offCtx.fillRect(x, y, 1, 1);
      }

      // edge diffusion
      offCtx.fillStyle = EDGE;
      for(let i=0;i<edgeN;i++){
        const p = base[randi(0, base.length-1)];
        const q = scatterInside(p.x, p.y, cx, cy, 0.06);
        offCtx.fillRect(q.x, q.y, 1, 1);
      }

      // center diffusion
      offCtx.fillStyle = CORE;
      for(let i=0;i<centerN;i++){
        const p = base[randi(0, base.length-1)];
        const q = scatterInside(p.x, p.y, cx, cy, 0.18);
        offCtx.fillRect(q.x, q.y, 1, 1);
      }

      // crisp outline
      offCtx.shadowBlur = 0;
      offCtx.fillStyle = CORE;
      for(const p of base){
        offCtx.fillRect(p.x, p.y, 2, 2);
      }

      offCtx.restore();

      state.ready = true;
    }

    // animate: only drawImage + tiny transform
    let last = 0;
    function loop(ts){
      requestAnimationFrame(loop);
      if(!state.ready) return;

      // cap ~60fps
      if(ts - last < 16) return;
      last = ts;

      const t = ts/1000;

      // smooth pulse
      const pulse = 1 + 0.035*Math.sin(t*2.2);
      const sway = 0.010*Math.sin(t*1.4);

      ctx.clearRect(0,0,state.w,state.h);

      // dark base
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.fillRect(0,0,state.w,state.h);

      // burst makes it brighter (cheap)
      const burst = state.burst;
      if(burst > 0){
        ctx.globalAlpha = 1;
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = "rgba(210,170,255,0.08)";
        ctx.fillRect(0,0,state.w,state.h);
        ctx.restore();
        state.burst = Math.max(0, burst - 0.06);
      }

      // draw pre-rendered heart with transform
      const cx = state.cx, cy = state.cy;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(sway);
      ctx.scale(pulse, pulse);
      ctx.translate(-cx, -cy);
      ctx.drawImage(off, 0, 0, state.w, state.h);
      ctx.restore();
    }

    canvas.addEventListener("pointerdown", () => { state.burst = 1; });

    resize();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
