<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–í–∞–ª–µ–Ω—Ç–∏–Ω–∫–∞ üíú</title>

  <style>
    :root{
      --bg1:#06060a; --bg2:#0b0820;
      --text:#f6f3ff; --muted:rgba(246,243,255,.75);
      --stroke:rgba(255,255,255,.14);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 700px at 20% 10%, #2a0f3a 0%, transparent 55%),
        radial-gradient(900px 600px at 90% 30%, #121b5c 0%, transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }
    .wrap{
      min-height:100%;
      display:grid; place-items:center;
      padding:22px; gap:10px; text-align:center;
    }
    .badge{
      padding:6px 12px;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.04);
      border-radius:999px;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--muted);
    }
    h1{margin:6px 0 0; font-size:clamp(26px,3.6vw,44px)}
    .sub{margin:0 0 12px; color:var(--muted)}

    .card{
      width:min(860px, 94vw);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius:24px;
      padding:16px;
      display:grid; gap:12px;
      box-shadow:0 18px 70px rgba(0,0,0,.55);
    }
    .stage{
      width:100%;
      height:min(560px, 66vh);
      border-radius:18px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      position:relative;
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    .btn{
      justify-self:center;
      cursor:pointer;
      border:none;
      padding:12px 16px;
      border-radius:14px;
      color:var(--text);
      background:linear-gradient(90deg, rgba(186,120,255,.86), rgba(126,105,255,.86));
      box-shadow: 0 12px 40px rgba(180,120,255,.18);
      font-weight:700;
    }
    .msg{
      text-align:left;
      padding:16px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
    }
    .hidden{display:none}
    .sig{margin-top:10px; opacity:.75; font-style:italic}
  </style>
</head>

<body>
  <main class="wrap">
    <div class="badge">üíå –í–ê–õ–ï–ù–¢–ò–ù–ö–ê</div>
    <h1>–Ø —Ç–µ–±–µ –ª—é–±–ª—é</h1>
    <p class="sub">–ù–∞—Ç–∏—Å–Ω–∏ —Å–µ—Ä–¥–µ—á–∫–æ ‚ú®</p>

    <section class="card">
      <div class="stage">
        <canvas id="c"></canvas>
      </div>

      <button id="btn" class="btn">–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ—Å–ª–∞–Ω–Ω—è</button>

      <div id="msg" class="msg hidden">
        <h2>–ú–æ—î –ø–æ—Å–ª–∞–Ω–Ω—è –¥–ª—è —Ç–µ–±–µ</h2>
        <p>
          –¢–∏ ‚Äî –º–æ—è –Ω–∞–π—Ç–µ–ø–ª—ñ—à–∞ –ª—é–¥–∏–Ω–∞. –î—è–∫—É—é, —â–æ —Ç–∏ —î. üíú<br/>
          –•–æ—á—É —â–µ –±–∞–≥–∞—Ç–æ-–±–∞–≥–∞—Ç–æ –Ω–∞—à–∏—Ö –¥–Ω—ñ–≤ —Ä–∞–∑–æ–º.
        </p>
        <div class="sig">‚Äî –¢–≤–æ—è –ù—ñ–∫–∞</div>
      </div>
    </section>
  </main>

  <script>
    // toggle
    const btn = document.getElementById("btn");
    const msg = document.getElementById("msg");
    btn.addEventListener("click", () => {
      msg.classList.toggle("hidden");
      btn.textContent = msg.classList.contains("hidden") ? "–í—ñ–¥–∫—Ä–∏—Ç–∏ –ø–æ—Å–ª–∞–Ω–Ω—è" : "–°—Ö–æ–≤–∞—Ç–∏ –ø–æ—Å–ª–∞–Ω–Ω—è";
    });

    // ===== Optimized heart particles (smooth + fast) =====
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: true });

    // Purple neon palette
    const CORE = [186, 120, 255];      // main violet
    const GLOW = [120, 70, 255];       // deeper violet glow

    const state = { w:0, h:0, cx:0, cy:0, dpr:1, burst:0 };
    let points = [];     // {x,y,layer,size}
    let ready = false;

    const rand = (a=0,b=1)=> a + Math.random()*(b-a);
    const randi = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));
    const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));

    function resize(){
      const r = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      state.w = r.width;
      state.h = r.height;
      state.cx = r.width/2;
      state.cy = r.height/2;
      state.dpr = dpr;

      // rebuild points on resize
      buildPoints();
    }
    window.addEventListener("resize", resize);

    // Heart curve
    function heartXY(t){
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
      return {x,y};
    }

    function scatterInside(x, y, beta=0.15){
      const ratioX = -beta * Math.log(Math.random());
      const ratioY = -beta * Math.log(Math.random());
      const dx = ratioX * (x - state.cx);
      const dy = ratioY * (y - state.cy);
      return { x: x - dx, y: y - dy };
    }

    // Build once (lighter than Tkinter version)
    function buildPoints(){
      const ENLARGE = Math.min(state.w, state.h) * 0.030; // auto-scale
      const baseN = 1200;      // was 2000 (lighter)
      const edgeN = 2200;      // was ~6000 (lighter)
      const centerN = 1800;    // was 4000 (lighter)
      const haloN = 1400;      // was 3000-7000 (lighter)

      points = [];

      // Base edge points
      const base = [];
      for(let i=0;i<baseN;i++){
        const t = rand(0, Math.PI*2);
        const p = heartXY(t);
        const x = p.x * ENLARGE + state.cx;
        const y = p.y * ENLARGE + state.cy;
        base.push({x,y});
        points.push({x,y, layer:"core", size:randi(1,2)});
      }

      // Edge diffusion
      for(let i=0;i<edgeN;i++){
        const p = base[randi(0, base.length-1)];
        const q = scatterInside(p.x, p.y, 0.06);
        points.push({x:q.x, y:q.y, layer:"edge", size:1});
      }

      // Center diffusion
      for(let i=0;i<centerN;i++){
        const p = base[randi(0, base.length-1)];
        const q = scatterInside(p.x, p.y, 0.18);
        points.push({x:q.x, y:q.y, layer:"center", size:1});
      }

      // Halo (slightly larger)
      for(let i=0;i<haloN;i++){
        const t = rand(0, Math.PI*2);
        const p = heartXY(t);
        const x = p.x * (ENLARGE*1.08) + state.cx + randi(-10,10);
        const y = p.y * (ENLARGE*1.08) + state.cy + randi(-10,10);
        points.push({x,y, layer:"halo", size:1});
      }

      ready = true;
    }

    function rgba([r,g,b], a){ return `rgba(${r},${g},${b},${a})`; }

    // Smooth animation: small pulse + gentle breathing (no chaotic re-calc)
    let lastTs = 0;
    function frame(ts){
      requestAnimationFrame(frame);
      if(!ready) return;

      // cap to 60fps (avoid overscheduling)
      const dt = ts - lastTs;
      if(dt < 16) return;
      lastTs = ts;

      const t = ts / 1000;

      // pulse scale (very smooth)
      const pulse = 1 + 0.035*Math.sin(t*2.2);
      const sway  = 0.012*Math.sin(t*1.4); // tiny sway
      const cx = state.cx;
      const cy = state.cy;

      ctx.clearRect(0,0,state.w,state.h);

      // subtle dark base inside stage
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.fillRect(0,0,state.w,state.h);

      // glow pass
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.shadowColor = rgba(GLOW, 0.65);
      ctx.shadowBlur = 18;

      const burstBoost = state.burst > 0 ? 0.25*state.burst : 0;

      for(const p of points){
        // apply pulse around center
        const dx0 = (p.x - cx);
        const dy0 = (p.y - cy);
        const x = cx + dx0*pulse + dy0*sway;
        const y = cy + dy0*pulse;

        let a = 0.92;
        if(p.layer==="halo") a = 0.35;
        if(p.layer==="edge") a = 0.65;
        if(p.layer==="center") a = 0.85;
        a = clamp(a + burstBoost, 0, 1);

        ctx.fillStyle = rgba(CORE, a);
        ctx.fillRect(x, y, p.size, p.size);
      }
      ctx.restore();

      // crisp pass
      ctx.save();
      ctx.shadowBlur = 0;
      for(const p of points){
        const dx0 = (p.x - cx);
        const dy0 = (p.y - cy);
        const x = cx + dx0*pulse + dy0*sway;
        const y = cy + dy0*pulse;

        let a = 0.85;
        if(p.layer==="halo") a = 0.25;
        if(p.layer==="edge") a = 0.55;
        if(p.layer==="center") a = 0.78;

        ctx.fillStyle = rgba(CORE, a);
        ctx.fillRect(x, y, p.size, p.size);
      }
      ctx.restore();

      // burst decay
      state.burst = Math.max(0, state.burst - 0.06);
    }

    // click -> burst
    canvas.addEventListener("pointerdown", () => { state.burst = 1; });

    // init
    resize();
    requestAnimationFrame(frame);
  </script>
</body>
</html>
